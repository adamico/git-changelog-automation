#!/bin/bash
#
# Git Changelog Automation
#
# A standalone tool for generating changelogs from conventional commits.
# Parses git history to create categorized changelog entries automatically.
#
# Usage:
#   changelog [from_tag] [to_tag]           # Generate changelog
#   changelog --release VERSION [DATE]      # Release version
#   changelog --install-hooks               # Install git hooks
    echo ""
#

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Version
VERSION="1.0.0"

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="${PROJECT_DIR:-$(pwd)}"
CHANGELOG_FILE="${CHANGELOG_FILE:-$PROJECT_DIR/CHANGELOG.md}"
CHANGELOG_BACKUP="$CHANGELOG_FILE.backup"
CONFIG_FILE="${GIT_CHANGELOG_CONFIG:-$PROJECT_DIR/git-conventional-commits.yaml}"

# Print colored message
print_color() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# Check if git-conventional-commits is available (optional dependency)
check_dependencies() {
    if ! command -v npx &> /dev/null; then
        print_color "$YELLOW" "Note: npx not available. Using built-in commit parsing."
        return 1
    fi
    
    if ! npx git-conventional-commits version &> /dev/null 2>&1; then
        print_color "$YELLOW" "Note: git-conventional-commits not found. Using built-in commit parsing."
        return 1
    fi
    
    return 0
}

# Validate CHANGELOG is in sync with git tags
validate_changelog_sync() {
    if [ ! -f "$CHANGELOG_FILE" ]; then
        return 0  # No changelog yet, nothing to validate
    fi
    
    # Get all version tags (v1.0.0 format or 1.0.0 format)
    local git_tags=$(git tag -l | grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+$' | sed 's/^v//' | sort -V)
    
    if [ -z "$git_tags" ]; then
        return 0  # No tags yet
    fi
    
    # Get versions from CHANGELOG (extract [X.Y.Z] format)
    local changelog_versions=$(grep -oP '(?<=## \[)[0-9]+\.[0-9]+\.[0-9]+(?=\])' "$CHANGELOG_FILE" | sort -V)
    
    # Find missing versions (in git tags but not in changelog)
    local missing_versions=""
    while IFS= read -r tag_version; do
        if ! echo "$changelog_versions" | grep -q "^${tag_version}$"; then
            missing_versions="${missing_versions}${tag_version}"$'\n'
        fi
    done <<< "$git_tags"
    
    if [ -n "$missing_versions" ]; then
        print_color "$YELLOW" "Warning: CHANGELOG is out of sync with git tags!" >&2
        print_color "$YELLOW" "Missing versions in CHANGELOG:" >&2
        echo "$missing_versions" | grep -v '^$' | while read -r version; do
            local tag_date=$(git log -1 --format=%ad --date=short "v${version}" 2>/dev/null || git log -1 --format=%ad --date=short "${version}" 2>/dev/null)
            echo "  - $version (tagged on ${tag_date:-unknown})" >&2
        done
        echo "" >&2
        
        if [ "$auto_accept" = "true" ]; then
            print_color "$GREEN" "Auto-adding missing versions to CHANGELOG..." >&2
            add_missing_versions "$missing_versions"
            return 0
        fi
        
        read -p "Add missing versions to CHANGELOG? (y/n): " -n 1 -r >&2
        echo "" >&2
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            add_missing_versions "$missing_versions"
        else
            print_color "$YELLOW" "Skipping sync. CHANGELOG may be incomplete." >&2
        fi
    fi
}

# Add missing versions to CHANGELOG
add_missing_versions() {
    local missing_versions=$1
    
    # Backup current changelog
    cp "$CHANGELOG_FILE" "$CHANGELOG_BACKUP"
    
    # Sort missing versions in descending order (newest first)
    local sorted_missing=$(echo "$missing_versions" | grep -v '^$' | sort -V -r)
    
    # Get all tags sorted by version
    local all_tags=$(git tag -l --sort=-version:refname | grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+$')
    
    # Create entries for each missing version with real commits
    local entries_file=$(mktemp)
    echo "$sorted_missing" | while read -r version; do
        [ -z "$version" ] && continue
        
        local tag="v${version}"
        # Try with v prefix first, then without
        git rev-parse "$tag" >/dev/null 2>&1 || tag="${version}"
        
        local tag_date=$(get_tag_date "$tag")
        [ -z "$tag_date" ] && tag_date=$(date +%Y-%m-%d)
        
        print_color "$GREEN" "Adding version $version with real commits..." >&2
        
        # Find the previous (older) tag to determine commit range
        local prev_tag=""
        local found_current=false
        while IFS= read -r t; do
            local t_version="${t#v}"
            if [ "$t_version" = "$version" ]; then
                found_current=true
                continue
            fi
            if [ "$found_current" = true ]; then
                prev_tag="$t"
                break
            fi
        done <<< "$all_tags"
        
        # Determine git range for commits
        local git_range
        if [ -n "$prev_tag" ]; then
            git_range="$prev_tag..$tag"
            print_color "$CYAN" "  Range: $prev_tag..$tag" >&2
        else
            git_range="$tag"
            print_color "$CYAN" "  Range: all commits up to $tag" >&2
        fi
        
        # Use add_version_section to generate real commits
        add_version_section "$version" "$tag_date" "$git_range" "$entries_file"
    done
    
    # Insert new entries into CHANGELOG before footer
    local temp_file=$(mktemp)
    
    # Get everything before footer (excluding footer line)
    sed -n '1,/^---/p' "$CHANGELOG_FILE" | sed '$d' > "$temp_file"
    
    # Add new version sections
    cat "$entries_file" >> "$temp_file"
    
    # Add footer back
    sed -n '/^---/,$p' "$CHANGELOG_FILE" >> "$temp_file"
    
    mv "$temp_file" "$CHANGELOG_FILE"
    rm -f "$entries_file" "$CHANGELOG_BACKUP"
    
    print_color "$GREEN" "✓ CHANGELOG synchronized with git tags (real commits added)!" >&2
}
get_latest_tag() {
    git describe --tags --abbrev=0 2>/dev/null || echo ""
}

# Clean duplicate entries from CHANGELOG
clean_duplicates() {
    if [ ! -f "$CHANGELOG_FILE" ]; then
        print_color "$YELLOW" "No CHANGELOG.md found"
        return 1
    fi
    
    print_color "$BLUE" "Scanning CHANGELOG for duplicate entries..."
    
    # Create temp file for cleaned changelog  
    local temp_clean="${CHANGELOG_FILE}.clean"
    local duplicates_found=0
    
    # Use awk to remove duplicate commit lines while preserving order
    awk '
    /^- (feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert):/ {
        if (seen[$0]++) {
            next  # Skip duplicate
        }
    }
    { print }
    ' "$CHANGELOG_FILE" > "$temp_clean"
    
    # Count how many lines were removed
    local original_lines=$(wc -l < "$CHANGELOG_FILE")
    local cleaned_lines=$(wc -l < "$temp_clean")
    duplicates_found=$((original_lines - cleaned_lines))
    
    if [ "$duplicates_found" -gt 0 ]; then
        print_color "$GREEN" "✓ Removed $duplicates_found duplicate entries"
        cp "$CHANGELOG_FILE" "${CHANGELOG_FILE}.backup"
        mv "$temp_clean" "$CHANGELOG_FILE"
        print_color "$GREEN" "✓ CHANGELOG cleaned (backup saved)"
        return 0
    else
        print_color "$GREEN" "✓ No duplicates found"
        rm -f "$temp_clean"
        return 0
    fi
}

# Rebuild entire CHANGELOG from git tag history
# Get the date of a git tag
get_tag_date() {
    local tag=$1
    git log -1 --format=%ai "$tag" 2>/dev/null | cut -d' ' -f1
}

# Extract commits by type from a git range
extract_commits_by_type() {
    local git_range=$1
    local commit_type=$2
    
    git log --pretty=format:"%s" "$git_range" 2>/dev/null | grep -E "^${commit_type}:" || true
}

# Add a changelog section with commits
add_changelog_section() {
    local section_title=$1
    local commits=$2
    local changelog_file=$3
    
    if [ -n "$commits" ]; then
        echo "### $section_title" >> "$changelog_file"
        echo "$commits" | while IFS= read -r line; do
            [ -n "$line" ] && echo "- $line" >> "$changelog_file"
        done
        echo "" >> "$changelog_file"
    fi
}

# Add version section to changelog
add_version_section() {
    local version=$1
    local date=$2
    local git_range=$3
    local changelog_file=$4
    
    # Extract all commit types
    local feat=$(extract_commits_by_type "$git_range" "feat")
    local fix=$(extract_commits_by_type "$git_range" "fix")
    local docs=$(extract_commits_by_type "$git_range" "docs")
    local refactor=$(extract_commits_by_type "$git_range" "refactor")
    local perf=$(extract_commits_by_type "$git_range" "perf")
    local test=$(extract_commits_by_type "$git_range" "test")
    local build=$(extract_commits_by_type "$git_range" "build")
    local ci=$(extract_commits_by_type "$git_range" "ci")
    local style=$(extract_commits_by_type "$git_range" "style")
    local chore=$(extract_commits_by_type "$git_range" "chore")
    local revert=$(extract_commits_by_type "$git_range" "revert")
    
    # Only add section if there are commits
    if [ -z "$feat" ] && [ -z "$fix" ] && [ -z "$docs" ] && \
       [ -z "$refactor" ] && [ -z "$perf" ] && [ -z "$test" ] && \
       [ -z "$build" ] && [ -z "$ci" ] && [ -z "$style" ] && \
       [ -z "$chore" ] && [ -z "$revert" ]; then
        return 0
    fi
    
    # Add version header
    echo "## [$version] - $date" >> "$changelog_file"
    echo "" >> "$changelog_file"
    
    # Add sections
    add_changelog_section "Added" "$feat" "$changelog_file"
    add_changelog_section "Fixed" "$fix" "$changelog_file"
    add_changelog_section "Documentation" "$docs" "$changelog_file"
    add_changelog_section "Changed" "$refactor" "$changelog_file"
    add_changelog_section "Performance" "$perf" "$changelog_file"
    add_changelog_section "Tests" "$test" "$changelog_file"
    add_changelog_section "Build" "$build" "$changelog_file"
    add_changelog_section "CI/CD" "$ci" "$changelog_file"
    add_changelog_section "Style" "$style" "$changelog_file"
    add_changelog_section "Chores" "$chore" "$changelog_file"
    add_changelog_section "Reverted" "$revert" "$changelog_file"
}

# Rebuild entire CHANGELOG from git tag history
rebuild_changelog() {
    print_color "$BLUE" "Rebuilding CHANGELOG from git tag history..."
    
    # Backup existing CHANGELOG
    if [ -f "$CHANGELOG_FILE" ]; then
        cp "$CHANGELOG_FILE" "${CHANGELOG_FILE}.backup"
        print_color "$YELLOW" "✓ Backed up existing CHANGELOG"
    fi
    
    # Create new CHANGELOG with header
    echo "# Changelog" > "$CHANGELOG_FILE"
    echo "" >> "$CHANGELOG_FILE"
    
    # Get all tags sorted by version (newest first)
    local tags=$(git tag -l --sort=-version:refname)
    
    if [ -z "$tags" ]; then
        print_color "$YELLOW" "No git tags found. Nothing to rebuild."
        return 1
    fi
    
    local prev_tag=""
    local tag_count=0
    
    # Process each tag
    for tag in $tags; do
        tag_count=$((tag_count + 1))
        
        # Handle first tag (check for unreleased commits, then continue)
        if [ -z "$prev_tag" ]; then
            if [ "$(git rev-parse HEAD 2>/dev/null)" != "$(git rev-parse "$tag" 2>/dev/null)" ]; then
                # Add unreleased section
                print_color "$CYAN" "Adding unreleased changes after $tag..."
                add_version_section "Unreleased" "$(date +%Y-%m-%d)" "$tag..HEAD" "$CHANGELOG_FILE"
            fi
            prev_tag="$tag"
            continue  # Skip to next iteration - we'll process this tag then
        fi
        
        # Now process the previous (newer) tag using current tag as range boundary
        local prev_version="${prev_tag#v}"
        local prev_date=$(get_tag_date "$prev_tag")
        local git_range="$tag..$prev_tag"
        
        print_color "$CYAN" "Processing $prev_tag ($prev_version) - $prev_date..."
        add_version_section "$prev_version" "$prev_date" "$git_range" "$CHANGELOG_FILE"
        
        # Remember current tag for next iteration
        prev_tag="$tag"
    done
    
    # After loop: process the last (oldest) tag
    if [ -n "$prev_tag" ]; then
        local last_version="${prev_tag#v}"
        local last_date=$(get_tag_date "$prev_tag")
        print_color "$CYAN" "Processing $prev_tag ($last_version) - $last_date..."
        add_version_section "$last_version" "$last_date" "$prev_tag" "$CHANGELOG_FILE"
    fi
    print_color "$GREEN" "✓ Rebuilt CHANGELOG with $tag_count versions"
    if [ -f "${CHANGELOG_FILE}.backup" ]; then
        print_color "$GREEN" "✓ Backup saved as ${CHANGELOG_FILE}.backup"
    fi
    return 0
}

get_existing_commits() {
    if [ ! -f "$CHANGELOG_FILE" ]; then
        return 0
    fi
    # Extract all lines that look like commit messages (start with "- " and have conventional prefix)
    grep -E "^- (feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert):" "$CHANGELOG_FILE" 2>/dev/null || true
}

# Generate changelog
generate_changelog() {
    local from_ref=$1
    local to_ref=${2:-HEAD}
    
    print_color "$BLUE" "Generating changelog..." >&2
    
    if [ -z "$from_ref" ]; then
        from_ref=$(get_latest_tag)
        if [ -z "$from_ref" ]; then
            print_color "$YELLOW" "No tags found. Generating changelog from all commits..." >&2
            from_ref=""
        else
            print_color "$GREEN" "Using latest tag: $from_ref" >&2
        fi
    fi
    
    if [ -n "$from_ref" ]; then
        print_color "$BLUE" "Changelog range: $from_ref...$to_ref" >&2
    else
        print_color "$BLUE" "Generating changelog from all commits to $to_ref" >&2
    fi
    
    # Generate changelog using git log parsing
    local temp_file
    temp_file=$(mktemp)
    
    print_color "$BLUE" "Parsing commits for conventional format..." >&2
    
    local git_range
    if [ -n "$from_ref" ]; then
        git_range="$from_ref..$to_ref"
    else
        git_range="$to_ref"
    fi
    
    # Extract commits by type
    local feat_commits=$(git log --pretty=format:"%s" "$git_range" | grep -E "^feat:" || true)
    local fix_commits=$(git log --pretty=format:"%s" "$git_range" | grep -E "^fix:" || true)
    local docs_commits=$(git log --pretty=format:"%s" "$git_range" | grep -E "^docs:" || true)
    local refactor_commits=$(git log --pretty=format:"%s" "$git_range" | grep -E "^refactor:" || true)
    local perf_commits=$(git log --pretty=format:"%s" "$git_range" | grep -E "^perf:" || true)
    local test_commits=$(git log --pretty=format:"%s" "$git_range" | grep -E "^test:" || true)
    local build_commits=$(git log --pretty=format:"%s" "$git_range" | grep -E "^build:" || true)
    local ci_commits=$(git log --pretty=format:"%s" "$git_range" | grep -E "^ci:" || true)
    local style_commits=$(git log --pretty=format:"%s" "$git_range" | grep -E "^style:" || true)
    local chore_commits=$(git log --pretty=format:"%s" "$git_range" | grep -E "^chore:" || true)
    local revert_commits=$(git log --pretty=format:"%s" "$git_range" | grep -E "^revert:" || true)
    
    
    # Get existing commits from CHANGELOG for deduplication
    local existing_commits=$(get_existing_commits)
    
    # Deduplicate commits by removing already-documented entries
    deduplicate_commits() {
        local commits="$1"
        [ -z "$commits" ] && return 0
        [ -z "$existing_commits" ] && echo "$commits" && return 0
        
        echo "$commits" | while IFS= read -r commit; do
            [ -z "$commit" ] && continue
            # Check if this exact commit message is already in CHANGELOG
            echo "$existing_commits" | grep -Fxq "- $commit" || echo "$commit"
        done
    }
    
    # Apply deduplication to all commit types
    feat_commits=$(deduplicate_commits "$feat_commits")
    fix_commits=$(deduplicate_commits "$fix_commits")
    docs_commits=$(deduplicate_commits "$docs_commits")
    refactor_commits=$(deduplicate_commits "$refactor_commits")
    perf_commits=$(deduplicate_commits "$perf_commits")
    test_commits=$(deduplicate_commits "$test_commits")
    build_commits=$(deduplicate_commits "$build_commits")
    ci_commits=$(deduplicate_commits "$ci_commits")
    style_commits=$(deduplicate_commits "$style_commits")
    chore_commits=$(deduplicate_commits "$chore_commits")
    revert_commits=$(deduplicate_commits "$revert_commits")
    if [ -z "$feat_commits" ] && [ -z "$fix_commits" ] && [ -z "$docs_commits" ] && \
       [ -z "$refactor_commits" ] && [ -z "$perf_commits" ] && [ -z "$test_commits" ] && \
       [ -z "$build_commits" ] && [ -z "$ci_commits" ] && [ -z "$style_commits" ] && \
       [ -z "$chore_commits" ] && [ -z "$revert_commits" ]; then
        print_color "$YELLOW" "No conventional commits found in range"
        rm "$temp_file"
        return 1
    fi
    
    # Generate changelog with sections (in priority order)
    {
        echo "## [Unreleased]"
        echo ""
        
        if [ -n "$feat_commits" ]; then
            echo "### Added"
            echo "$feat_commits" | while read -r line; do
                echo "- $line"
            done
            echo ""
        fi
        
        if [ -n "$fix_commits" ]; then
            echo "### Fixed"
            echo "$fix_commits" | while read -r line; do
                echo "- $line"
            done
            echo ""
        fi
        
        if [ -n "$refactor_commits" ]; then
            echo "### Changed"
            echo "$refactor_commits" | while read -r line; do
                echo "- $line"
            done
            echo ""
        fi
        
        if [ -n "$perf_commits" ]; then
            echo "### Performance"
            echo "$perf_commits" | while read -r line; do
                echo "- $line"
            done
            echo ""
        fi
        
        if [ -n "$docs_commits" ]; then
            echo "### Documentation"
            echo "$docs_commits" | while read -r line; do
                echo "- $line"
            done
            echo ""
        fi
        
        if [ -n "$style_commits" ]; then
            echo "### Style"
            echo "$style_commits" | while read -r line; do
                echo "- $line"
            done
            echo ""
        fi
        
        if [ -n "$test_commits" ]; then
            echo "### Tests"
            echo "$test_commits" | while read -r line; do
                echo "- $line"
            done
            echo ""
        fi
        
        if [ -n "$build_commits" ]; then
            echo "### Build"
            echo "$build_commits" | while read -r line; do
                echo "- $line"
            done
            echo ""
        fi
        
        if [ -n "$ci_commits" ]; then
            echo "### CI/CD"
            echo "$ci_commits" | while read -r line; do
                echo "- $line"
            done
            echo ""
        fi
        
        if [ -n "$chore_commits" ]; then
            echo "### Chores"
            echo "$chore_commits" | while read -r line; do
                echo "- $line"
            done
            echo ""
        fi
        
        if [ -n "$revert_commits" ]; then
            echo "### Reverted"
            echo "$revert_commits" | while read -r line; do
                echo "- $line"
            done
            echo ""
        fi
    } > "$temp_file"
    
    echo "$temp_file"
    return 0
}

# Update CHANGELOG.md
update_changelog() {
    local generated_file=$1
    
    # Backup existing changelog
    if [ -f "$CHANGELOG_FILE" ]; then
        cp "$CHANGELOG_FILE" "$CHANGELOG_BACKUP"
        print_color "$GREEN" "Created backup: $CHANGELOG_BACKUP" >&2
    fi
    
    # Extract sections from generated file
    local sections=("Added" "Fixed" "Changed" "Performance" "Documentation" "Style" "Tests" "Build" "CI/CD" "Chores" "Reverted")
    
    # Function to extract commits for a section
    extract_section() {
        local section=$1
        local file=$2
        sed -n "/^### $section/,/^### \|^## \|^$/p" "$file" | grep "^- " || true
    }
    
    # Merge sections from existing and new
    declare -A merged_sections
    for section in "${sections[@]}"; do
        local existing=$(extract_section "$section" "$CHANGELOG_FILE" 2>/dev/null || true)
        local new=$(extract_section "$section" "$generated_file" 2>/dev/null || true)
        
        if [ -n "$existing" ] && [ -n "$new" ]; then
            merged_sections["$section"]=$(echo -e "$existing\n$new" | sort -u)
        elif [ -n "$existing" ]; then
            merged_sections["$section"]="$existing"
        elif [ -n "$new" ]; then
            merged_sections["$section"]="$new"
        fi
    done
    
    # Create new changelog with merged content
    {
        echo "# Changelog"
        echo ""
        
        # Add Unreleased section if we have content
        local has_content=false
        for section in "${sections[@]}"; do
            if [ -n "${merged_sections[$section]}" ]; then
                has_content=true
                break
            fi
        done
        
        if [ "$has_content" = "true" ]; then
            echo "## [Unreleased]"
            echo ""
            
            # Add sections in order
            for section in "${sections[@]}"; do
                if [ -n "${merged_sections[$section]}" ]; then
                    echo "### $section"
                    echo "${merged_sections[$section]}"
                    echo ""
                fi
            done
        fi
        
        # Append all version sections (everything from first ## [version])
        if [ -f "$CHANGELOG_FILE" ]; then
            sed -n '/^## \[[0-9]/,$p' "$CHANGELOG_FILE"
        fi
    } > "$CHANGELOG_FILE.new"
    
    mv "$CHANGELOG_FILE.new" "$CHANGELOG_FILE"
    print_color "$GREEN" "Updated $CHANGELOG_FILE" >&2
}

# Interactive mode
interactive_update() {
    local auto_accept=$1
    
    if [ "$auto_accept" = "true" ]; then
        print_color "$GREEN" "Auto-accepting changes (non-interactive mode)"
        rm "$CHANGELOG_BACKUP"
        return 0
    fi
    
    print_color "$YELLOW" "Generated changelog entries. Review the changes:"
    echo ""
    git diff --no-index "$CHANGELOG_BACKUP" "$CHANGELOG_FILE" || true
    echo ""
    
    read -p "Accept these changes? (y/n): " -n 1 -r
    echo ""
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        print_color "$GREEN" "Changelog updated successfully!"
        rm "$CHANGELOG_BACKUP"
        return 0
    else
        print_color "$YELLOW" "Reverting changes..."
        mv "$CHANGELOG_BACKUP" "$CHANGELOG_FILE"
        return 1
    fi
}

# Release [Unreleased] to a version
# Update README version badge if it exists
update_readme_badge() {
    local version=$1
    local readme_file="$PROJECT_DIR/README.md"
    
    # Check if README.md exists
    if [ ! -f "$readme_file" ]; then
        return 0  # No README, nothing to do
    fi
    
    # Check if README has a version badge
    if ! grep -q "version-[0-9]\+\.[0-9]\+\.[0-9]\+-blue" "$readme_file" 2>/dev/null; then
        return 0  # No version badge found, nothing to do
    fi
    
    print_color "$BLUE" "Updating README.md version badge to $version..." >&2
    
    # Update the version badge
    sed -i "s/version-[0-9]\+\.[0-9]\+\.[0-9]\+-blue/version-$version-blue/g" "$readme_file"
    
    print_color "$GREEN" "✓ README.md version badge updated to $version" >&2
    
    return 0
}

release_version() {
    local version=$1
    local release_date=${2:-$(date +%Y-%m-%d)}
    
    if [ -z "$version" ]; then
        print_color "$RED" "Error: Version number required for release" >&2
        echo "Usage: changelog --release VERSION [DATE]" >&2
        return 1
    fi
    
    # Validate version format (basic semver check)
    if ! echo "$version" | grep -qE '^v?[0-9]+\.[0-9]+\.[0-9]+$'; then
        print_color "$RED" "Error: Invalid version format. Use semver (e.g., 1.2.3 or v1.2.3)" >&2
        return 1
    fi
    
    # Remove 'v' prefix if present
    version="${version#v}"
    
    print_color "$BLUE" "Releasing unreleased changes as version $version ($release_date)..." >&2
    
    # Check if there's unreleased content (between header and first version)
    local unreleased_content=$(sed -n '/^# Changelog/,/^## \[[0-9]/p' "$CHANGELOG_FILE" | grep "^- " || true)
    
    if [ -z "$unreleased_content" ]; then
        print_color "$YELLOW" "Warning: No unreleased content to release" >&2
        if [ "$auto_accept" != "true" ]; then
            read -p "Continue anyway? (y/n): " -n 1 -r >&2
            echo "" >&2
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                return 1
            fi
        else
            print_color "$GREEN" "Auto-accepting empty content (non-interactive mode)" >&2
        fi
    fi
    
    # Backup
    cp "$CHANGELOG_FILE" "$CHANGELOG_BACKUP"
    print_color "$GREEN" "Created backup: $CHANGELOG_BACKUP" >&2
    
    # Create temp file with new structure
    {
        # Header
        echo "# Changelog"
        echo ""
        
        # Convert unreleased content (between header and first version) to new version
        echo "## [$version] - $release_date"
        echo ""
        
        # Extract content between header and first version
        sed -n '/^# Changelog/,/^## \[[0-9]/p' "$CHANGELOG_FILE" | \
            sed '1d;$d' | \
            sed '/^## \[Unreleased\]/d'
        
        echo ""
        
        # Append all existing version sections
        awk '/^## \[[0-9]/ {found=1} found && /^---/ {exit} found {print}' "$CHANGELOG_FILE"
        
        # Append footer if exists
        sed -n '/^---/,$p' "$CHANGELOG_FILE"
    } > "$CHANGELOG_FILE.new"
    
    mv "$CHANGELOG_FILE.new" "$CHANGELOG_FILE"
    print_color "$GREEN" "Released as [$version]" >&2
    
    # Update or create VERSION file
    echo "$version" > "$PROJECT_DIR/VERSION"
    print_color "$GREEN" "Updated VERSION file to $version" >&2
    
    # Update README badge if it exists
    update_readme_badge "$version"

    
    return 0
}

# Install git hooks
install_hooks() {
    print_color "$BLUE" "=== Installing Git Hooks ==="
    echo ""
    
    # Check if .git directory exists
    if [ ! -d "$PROJECT_DIR/.git" ]; then
        print_color "$RED" "Error: Not a git repository. Run this from your project root."
        return 1
    fi
    
    local hooks_target="$PROJECT_DIR/.git/hooks"
    mkdir -p "$hooks_target"
    
    # Install commit-msg hook
    cat > "$hooks_target/commit-msg" << 'HOOK_EOF'
#!/bin/bash
# Validates conventional commit format

commit_msg=$(cat "$1")

if ! echo "$commit_msg" | grep -qE '^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?: .+'; then
    echo "❌ Invalid commit message format!"
    echo ""
    echo "Commit messages must follow conventional commits format:"
    echo "  <type>(<scope>): <subject>"
    echo ""
    echo "Types: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert"
    echo ""
    echo "Examples:"
    echo "  feat: add new feature"
    echo "  fix(parser): resolve parsing error"
    echo "  docs: update README"
    exit 1
fi
HOOK_EOF
    
    # Install prepare-commit-msg hook
    cat > "$hooks_target/prepare-commit-msg" << 'HOOK_EOF'
#!/bin/bash
# Prompts to update changelog for version commits

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2

# Only run for regular commits
if [ -n "$COMMIT_SOURCE" ]; then
    exit 0
fi

commit_msg=$(cat "$COMMIT_MSG_FILE")

# Detect version-related commits
if echo "$commit_msg" | grep -qiE '^(build|release|chore):.*(version|release|v[0-9]+\.[0-9]+\.[0-9]+)'; then
    echo "⚠️  Detected a release/version commit"
    echo "ℹ️  Consider updating CHANGELOG.md before committing"
    echo ""
    echo "You can run:"
    echo "  changelog"
    echo "  changelog --auto-accept  # For CI/automation"
    echo ""
fi

exit 0
HOOK_EOF
    
    chmod +x "$hooks_target/commit-msg"
    chmod +x "$hooks_target/prepare-commit-msg"
    
    print_color "$GREEN" "✓ Installed commit-msg"
    print_color "$GREEN" "✓ Installed prepare-commit-msg"
    echo ""
    print_color "$GREEN" "Git hooks installed successfully!"
    echo ""
    print_color "$BLUE" "Hooks installed:"
    echo "  • commit-msg         - Validates conventional commit format"
    echo "  • prepare-commit-msg - Prompts for changelog updates on release commits"
}

# Show help
# Show help
show_help() {
    print_color "$BLUE" "Git Changelog Automation v$VERSION"
    echo ""
    echo "Automatically generate changelogs from conventional commits."
    echo ""
    print_color "$YELLOW" "USAGE:"
    echo "  changelog [OPTIONS] [from_tag] [to_tag]"
    echo "  changelog --release VERSION [DATE]"
    echo "  changelog --install-hooks"
    echo "  changelog --clean"
    echo "  changelog --rebuild"
    echo "  changelog --help"
    echo ""
    print_color "$YELLOW" "EXAMPLES:"
    print_color "$GREEN" "  changelog                           ${NC}  # Generate from last tag to HEAD"
    print_color "$GREEN" "  changelog v1.0.0                    ${NC}  # Generate from v1.0.0 to HEAD"
    print_color "$GREEN" "  changelog v1.0.0 v1.1.0             ${NC}  # Generate from v1.0.0 to v1.1.0"
    print_color "$GREEN" "  changelog --auto-accept v1.0.0      ${NC}  # Generate and auto-accept"
    print_color "$GREEN" "  changelog -y                        ${NC}  # Generate from last tag, auto-accept"
    echo ""
    print_color "$GREEN" "  changelog --release 1.2.0           ${NC}  # Convert unreleased to [1.2.0]"
    print_color "$GREEN" "  changelog --release v1.2.0 2025-11-01 ${NC}# Release with specific date"
    print_color "$GREEN" "  changelog -r 1.2.0 -y               ${NC}  # Release and auto-accept"
    echo ""
    print_color "$GREEN" "  changelog --install-hooks           ${NC}  # Install git hooks for validation"
    print_color "$GREEN" "  changelog --clean                   ${NC}  # Remove duplicate entries from CHANGELOG"
    print_color "$GREEN" "  changelog --rebuild                 ${NC}  # Rebuild entire CHANGELOG from git tags"
    echo ""
    print_color "$YELLOW" "AUTOMATIC UPDATES:"
    echo "  When releasing a version, the tool automatically:"
    echo "    • Creates/updates VERSION file with the new version"
    echo "    • Updates README.md version badge (if present)"
    echo ""
    print_color "$YELLOW" "OPTIONS:"
    echo "  --non-interactive, --auto-accept, -y"
    echo "                    Auto-accept changes without prompting"
    echo "  --release VERSION [DATE], -r VERSION [DATE]"
    echo "                    Convert unreleased section to a version release"
    echo "                    DATE defaults to today if not specified"
    echo "  --install-hooks   Install git hooks for commit validation"
    echo "  --version, -v     Show version information"
    echo "  --help, -h        Show this help message"
    echo ""
    print_color "$YELLOW" "CONVENTIONAL COMMITS:"
    echo "  Supported commit types:"
    echo "    feat      - New features (Added section)"
    echo "    fix       - Bug fixes (Fixed section)"
    echo "    refactor  - Code changes (Changed section)"
    echo "    perf      - Performance improvements"
    echo "    docs      - Documentation changes"
    echo "    style     - Code style changes"
    echo "    test      - Test additions/modifications"
    echo "    build     - Build system changes"
    echo "    ci        - CI/CD changes"
    echo "    chore     - Maintenance tasks"
    echo "    revert    - Reverted changes"
    echo ""
    print_color "$YELLOW" "ENVIRONMENT VARIABLES:"
    echo "  CHANGELOG_FILE       Path to CHANGELOG.md (default: ./CHANGELOG.md)"
    echo "  PROJECT_DIR          Project root directory (default: current directory)"
    echo "  GIT_CHANGELOG_CONFIG Path to config YAML (optional)"
    echo ""
    print_color "$YELLOW" "AUTOMATION:"
    echo "  Use --auto-accept for CI/CD pipelines and automated workflows."
    echo "  The tool will skip interactive prompts and apply changes automatically."
    echo ""
    print_color "$YELLOW" "MORE INFO:"
    echo "  Documentation: https://github.com/adamico/git-changelog-automation"
    echo "  Report issues: https://github.com/adamico/git-changelog-automation/issues"
    echo ""
}

# Main
main() {
    local from_ref=""
    local to_ref=""
    local auto_accept="false"
    local release_mode="false"
    local release_version=""
    local release_date=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --non-interactive|--auto-accept|-y)
                auto_accept="true"
                shift
                ;;
            --release|-r)
                release_mode="true"
                shift
                if [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; then
                    release_version=$1
                    shift
                    # Optional date parameter
                    if [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; then
                        release_date=$1
                        shift
                    fi
                fi
                ;;
            --install-hooks)
                install_hooks
                exit $?
                ;;
            --clean)
                clean_duplicates
                exit $?
                ;;
            --rebuild)
                rebuild_changelog
                exit $?
                ;;
            --version|-v)
                echo "Git Changelog Automation v$VERSION"
                exit 0
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                if [ -z "$from_ref" ]; then
                    from_ref=$1
                elif [ -z "$to_ref" ]; then
                    to_ref=$1
                fi
                shift
                ;;
        esac
    done
    
    print_color "$BLUE" "=== Git Changelog Automation v$VERSION ==="
    echo ""
    
    # Validate CHANGELOG is in sync with git tags (skip in release mode)
    if [ "$release_mode" != "true" ]; then
        validate_changelog_sync
        echo ""
    fi
    
    # Handle release mode
    if [ "$release_mode" = "true" ]; then
        if [ -z "$release_version" ]; then
            print_color "$RED" "Error: --release requires a version number"
            echo ""
            echo "Usage: changelog --release VERSION [DATE]"
            echo "Example: changelog --release 1.2.0"
            echo "Example: changelog --release v1.2.0 2025-11-01"
            return 1
        fi
        
        if release_version "$release_version" "$release_date"; then
            if [ "$auto_accept" = "true" ]; then
                print_color "$GREEN" "Release completed (auto-accepted)"
                rm -f "$CHANGELOG_BACKUP"
            else
                interactive_update "$auto_accept"
            fi
        else
            return 1
        fi
        return 0
    fi
    
    # Check dependencies (optional)
    check_dependencies || true
    
    # Generate changelog
    local generated_file
    if generated_file=$(generate_changelog "$from_ref" "$to_ref"); then
        update_changelog "$generated_file"
        rm "$generated_file"
        
        # Interactive review
        if [ -f "$CHANGELOG_BACKUP" ]; then
            interactive_update "$auto_accept"
        else
            print_color "$GREEN" "Changelog created successfully!"
        fi
    else
        print_color "$YELLOW" "No changes to add to changelog."
        return 1
    fi
}

# Run main if not sourced
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    main "$@"
fi
